#!/usr/bin/env octave-qf

# sdf.smooth   [type] [cutoff]   [sdf.in]    [sdf.out]
#        smooth sdf function by radial basis function [type]
#        types are
#          cubic : cubic spline
#          gauss :
#        Note: assume domain is periodic

1;
function r = w(r)
  global c
  if r > c; r = 0; return; endif

  r /= c; r *= 2.5;
  r = exp(-r^2);
endfunction

function read(fn)
  f = fopen(fn);
  read_header(f)
  read_data(f)
  fclose(f);
endfunction

function varargout = fscn(f, fmt) # simpler fscanf
  l = fgets(f);
  [varargout{1:nargout}] = strread(l, fmt);
endfunction

function read_header(f)
  global ex ey ez   nx ny nz
  [ex, ey, ez] = fscn(f, "%f %f %f");
  [nx, ny, nz] = fscn(f, "%d %d %d");
endfunction

function read_data(f)
  global nx ny nz
  global D
  D = fread(f, nx*ny*nz, "float32");
  D = reshape(D, nx, ny, nz);
endfunction

function write_header(f)
  global ex ey ez   nx ny nz
  fprintf(f, "%g %g %g\n", ex, ey, ez);
  fprintf(f, "%g %g %g\n", nx, ny, nz);
endfunction

function write_data(f)
  global E
  fwrite(f, E, "float32");
endfunction

function write(fn)
  global ex ey ez   nx ny nz   D
  f = fopen(fn, "w");
  write_header(f)
  write_data(f)
  fclose(f);
endfunction

function    parg(); global a; a = argv();               endfunction
function r = nxt(); global a; r = a{1}; a = {a{2:end}}; endfunction

function ini_e()
  global E nx ny nz
  E = zeros(nx, ny, nz);
endfunction

function ini_ker0(c0)
  global c # cutoff
  global sx sy sz
  global kx ky kz A
  c = c0;
  kx = fix(c/sx); ky = fix(c/sy); kz = fix(c/sz); # sum over [ix - kx; ix + ky]
endfunction

function ini_ker1(c)
  global kx ky kz
  global ww
  ww = zeros(2*kx+1,2*ky+1,2*kz+1);
  for ix=-kx:kx; ix0 = ix + kx + 1; x2 = sqx(ix);
  for iy=-ky:ky; iy0 = iy + ky + 1; y2 = sqy(iy);
  for iz=-kz:kz; iz0 = iz + kz + 1; z2 = sqz(iz);
      r = sqrt(x2 + y2 + z2);
      ww(ix0,iy0,iz0) = w(r);
  endfor endfor endfor
  ww ./= sum(ww(:));
  msg("numel(ww): %d", numel(ww));
endfunction

function s = sqx(k); s = gx(k).^2; endfunction
function s = sqy(k); s = gy(k).^2; endfunction
function s = sqz(k); s = gz(k).^2; endfunction

function r = gx(k); global sx; r = sx*k; endfunction
function r = gy(k); global sy; r = sy*k; endfunction
function r = gz(k); global sz; r = sz*k; endfunction

function e = dbl(e); e = double(e); endfunction
function ini_grid()
  global ex ey ez   nx ny nz
  global sx sy sz
  sx = ex/dbl(nx); sy = ey/dbl(ny); sz = ez/dbl(nz); # step
endfunction

function i = wrap(i, n)
  if     i < 1; i += n;
  elseif i > n; i -= n; endif
endfunction

function r = wx(r); global nx; r = wrap(r, nx); endfunction
function r = wy(r); global ny; r = wrap(r, ny); endfunction
function r = wz(r); global nz; r = wrap(r, nz); endfunction

function smooth0(x, y, z, f0)
  global E # output
  x = wx(x); y = wy(y); z = wz(z); # where to add
  E(x, y, z) += f0;
endfunction

function smooth1(x, y, z,   dx, dy, dz,   f0)
  x += dx; y += dy; z += dz;
  smooth0(x, y, z, f0);
endfunction

function smooth2(ixc, iyc, izc, v)
  global kx ky kz
  global ww
  for ix=-kx:kx; ix0 = ix + kx + 1;
  for iy=-ky:ky; iy0 = iy + ky + 1;
  for iz=-kz:kz; iz0 = iz + kz + 1;
      w0 = ww(ix0,iy0,iz0);
      smooth1(ixc, iyc, izc,   ix, iy, iz,   w0*v);
  endfor endfor endfor
endfunction

function smooth3(x, y, z)
  global D
  smooth2(x, y, z, D(x, y, z))
endfunction

function smooth_naive()
  global nx ny nz
  for ix = 1:nx; msg("ix: %03d/%03d", ix, nx);
  for iy = 1:ny;
  for iz = 1:nz; smooth3(ix, iy, iz);
  endfor endfor endfor
endfunction

function msg0(fmt, varargin); fprintf(stderr, fmt, [varargin{:}]); endfunction
function msg(fmt, varargin); msg0("sdf.smooth: "); msg0(fmt, [varargin{:}]); msg0("\n"); endfunction

function smooth_conv()
  global E D ww
  E = convn(D, ww, "same");
endfunction

function cap()
  global D
  max = 3; min = -3;
  i = D > max; D(i) = max;
  i = D < min; D(i) = min;
endfunction

parg(); # parse args
t = nxt(); # kernel type
c = str2num(nxt()); # cutoff
fi = nxt(); fo = nxt();

read(fi);

ini_e(); # init [o]utput buffer
ini_grid();
ini_ker0(c); # kernel
ini_ker1(c); # kernel

# smooth_naive();
cap();
smooth_conv();

write(fo);
