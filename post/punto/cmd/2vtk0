#!/bin/sh
set -u

: ${FMT="%05d"}

prog=u.punto.2vtk0

. u.punto.util

o="$1"; shift
i="$1"; shift

"$AWK" -v o="$o" -v i="$i" -v prog="$prog" -v fmt="$FMT" '
BEGIN {
    ini()
    arg()
    while (1) {
	r = read()
	write()
	if (r == EOF) break
    }
}

function ini() {
    id = 0
    # end of file/snapshot
    OK = 0; EOF = 1; EOS = 2
}

function nxt(   r) {
    r = getline < i
    if (r <= 0)  return EOF
    if (NF == 0) return EOS
    return OK
}

function assert_fi(f,   s) {
    if (f <= NF) return
    msg("fail to read file " i)
    msg(sprintf("expecting field: %d, found %d fields", f, NF))
    err("line: " $0)
}

function read_line(r,   k, v, i) {
    # global snap
    for (k in idx) {
	i = idx[k]
	assert_fi(i)
	snap[k, r] = $i
    }
}
function read(   r, s) { # s: status
    n = 0 # global number of particles
    while (1) {
	r = nxt()
	if (r == EOF) {s = EOF; break}
	if (r == EOS) {s = OK ; break}
	read_line(n++)
    }
    return s
}
function header(f) {
    print "# vtk DataFile Version 2.0" > f
    print "created with " prog         > f
    print "ASCII"                      > f
}
function write0(f) {
    msg(f)
    header(f)
}
function write() { # fn: file number (global)
    f = sprintf("%s/" fmt ".vtk", o, fn++)
    write0(f)
    close(f)
}

function arg(   i, k) {
    for (i = 1; i in ARGV; i++) {
	k = ARGV[i]; idx[k] = i; key[i] = k
    }
}
function msg(s) { printf "%s: %s\n", prog, s | "cat >&2" }
function err(s) { msg(s); exit(2) }
' "$@"

if test $? -ne 0; then err 'awk part failed'; fi
